<html>
<head>
<title>js.js Twitter Button</title>
<script type="text/javascript" src="../../src/libjs.O2.js"></script>
<script type="text/javascript" src="../../src/jsjs-wrapper.js"></script>
<script type="text/javascript">

function init() {
   var xhr = new XMLHttpRequest();
   xhr.open('GET', 'widgets.js', false); 
   xhr.send(null);
   if (xhr.status != 200) {
       throw("Failed to get JS for twitter");
   }
   var srcContents = xhr.responseText;
   
   function globalResolveProperty(propName) {
       console.log("global resolve " + propName);
       return 1;
   }
   function globalGetProperty(propName) {
       console.log('getting global property ' + propName);
       return undefined;
   }
   
   var jsObjs = JSJS.Init({'global_getter': JSJS.wrapGetter(globalGetProperty, JSJS.Types.bool),
       'global_resolver': JSJS.wrapResolver(globalResolveProperty)});
   
   function locationGetProperty(propName) {
       console.log("location get property " + propName);
       switch(propName) {
       case "hash":
           return {'type': JSJS.Types.charPtr, 'val': window.location.hash};
           break;
       case "host":
           return {'type': JSJS.Types.charPtr, 'val': window.location.host};
           break;
       case "hostname":
           return {'type': JSJS.Types.charPtr, 'val': window.location.hostname};
           break;
       case "href":
           return {'type': JSJS.Types.charPtr, 'val': window.location.href};
           break;
       case "pathname":
           return {'type': JSJS.Types.charPtr, 'val': window.location.pathname};
           break;
       case "port":
           return {'type': JSJS.Types.double, 'val': window.location.port};
           break;
       case "protocol":
           return {'type': JSJS.Types.charPtr, 'val': window.location.protocol};
           break;
       case "search":
           return {'type': JSJS.Types.charPtr, 'val': window.location.search};
           break;
       }
       throw "Not Implemented location prop - " + propName;
   }
   var jsLocationClass = JSJS.CreateClass(JSJS['JSCLASS_GLOBAL_FLAGS'],
           JSJS['PropertyStub'],
           JSJS['PropertyStub'],
           JSJS.wrapGetter(locationGetProperty, JSJS.Types.bool),
           JSJS['StrictPropertyStub'],
           JSJS['EnumerateStub'],
           JSJS['ResolveStub'],
           JSJS['ConvertStub'],
           JSJS['FinalizeStub']);
   var jsLocation = JSJS.DefineObject(jsObjs.cx, jsObjs.glob, "location", jsLocationClass, 0, 0);
   
   function screenGetProperty(propName) {
       console.log("screen get property " + propName);
       switch(propName) {
       case "width":
           return {'type': JSJS.Types.double, 'val': screen.width};
           break;
       case "height":
           return {'type': JSJS.Types.double, 'val': screen.height};
           break;
       }
       throw "Not Implemented screen prop - " + propName;
   }
   var jsScreenClass = JSJS.CreateClass(JSJS['JSCLASS_GLOBAL_FLAGS'],
           JSJS['PropertyStub'],
           JSJS['PropertyStub'],
           JSJS.wrapGetter(screenGetProperty, JSJS.Types.bool),
           JSJS['StrictPropertyStub'],
           JSJS['EnumerateStub'],
           JSJS['ResolveStub'],
           JSJS['ConvertStub'],
           JSJS['FinalizeStub']);
   var jsScreen = JSJS.DefineObject(jsObjs.cx, jsObjs.glob, "screen", jsScreenClass, 0, 0);
   
   function navigatorGetProperty(propName) {
       console.log("navigator get property " + propName);
       switch(propName) {
       case "doNotTrack":
           return {'type': JSJS.Types.double, 'val': 1};
           break;
       case "userAgent":
           return {'type': JSJS.Types.charPtr, 'val': navigator.userAgent};
           break;
       }
       throw "Not Implemented navigator prop - " + propName;
   }
   var jsNavigatorClass = JSJS.CreateClass(JSJS['JSCLASS_GLOBAL_FLAGS'],
           JSJS['PropertyStub'],
           JSJS['PropertyStub'],
           JSJS.wrapGetter(navigatorGetProperty, JSJS.Types.bool),
           JSJS['StrictPropertyStub'],
           JSJS['EnumerateStub'],
           JSJS['ResolveStub'],
           JSJS['ConvertStub'],
           JSJS['FinalizeStub']);
   var jsNavigator = JSJS.DefineObject(jsObjs.cx, jsObjs.glob, "navigator", jsNavigatorClass, 0, 0);
   
   var wrappedMap = {};
   
   function makeWrappedElement(elem, getter, setter, resolver) {
       function _elementBoxGetProperty(propName) {
           console.log('element box get ' + propName);
           return true;
       }
       function _elementBoxSetProperty(cx, obj, idStrReal, strict, val, jsval) {
           console.log('setting element box property ' + idStrReal + " = " + val + " / " + jsval);
           return undefined;
       }
       function _elementBoxResolveProperty(idStrReal) {
           console.log("element box resolve property " + idStrReal);
           return 1;
       }
       var elementBoxGetProperty = getter || _elementBoxGetProperty;
       var elementBoxSetProperty = setter || _elementBoxSetProperty
       var elementBoxResolveProperty = resolver || _elementBoxResolveProperty;
       var jsElementBox = JSJS.CreateClass(JSJS['JSCLASS_GLOBAL_FLAGS'],
               JSJS['PropertyStub'],
               JSJS['PropertyStub'],
               JSJS.wrapGetter(elementBoxGetProperty, JSJS.Types.bool),
               JSJS.wrapSetter(elementBoxSetProperty),
               JSJS['EnumerateStub'],
               JSJS.wrapResolver(elementBoxResolveProperty),
               JSJS['ConvertStub'],
               JSJS['FinalizeStub']);
       
       var objPtr = JSJS.NewObject(jsObjs.cx, jsElementBox, 0, 0);
       
       function elementCompareDocumentPosition(otherNode) {
           console.log("elementCompareDocumentPosition");
           throw "Not Implemented";
           return 0;
       }
       var wrappedCompareDocumentPosition = JSJS.wrapFunction({
           func: elementCompareDocumentPosition,
           args: [JSJS.Types.objPtr],
           returns: JSJS.Types.double});
       var ptrCompareDocumentPosition = JSJS.NewFunction(jsObjs.cx, wrappedCompareDocumentPosition, 1, "compareDocumentPosition");
       JSJS.SetProperty(jsObjs.cx, objPtr, "compareDocumentPosition", ptrCompareDocumentPosition);
       
       wrappedMap[objPtr] = elem;
       return objPtr;
   }
   
   
   function jsGetElementsByTagName(something) {
       console.log("getelementsbytagname " + something);
       return [];
   }
   var wrappedGetElementsByTagName = JSJS.wrapFunction({
       func: jsGetElementsByTagName,
       args: [JSJS.Types.charPtr],
       returns: JSJS.Types.arrayPtr});
   var ptrGetElementsByTagName = JSJS.NewFunction(jsObjs.cx, wrappedGetElementsByTagName, 1, "getElementsByTagName");
   
   function jsGetElementById(elemId) {
       console.log("getelementbyid " + elemId);
       var elem = document.getElementById(elemId);
       if (elem == null) {
           return 0;
       } else {
           throw "Not implemented getelementbyid";
       }
   }
   var wrappedGetElementById = JSJS.wrapFunction({
       func: jsGetElementById,
       args: [JSJS.Types.charPtr],
       returns: JSJS.Types.objPtr});
   var ptrGetElementById = JSJS.NewFunction(jsObjs.cx, wrappedGetElementById, 1, "getElementById");
   
    function jsIframeCloneNode(deep) {
            console.log("cloneIframeNode ");
            {
                var wrappedElem = document.createElement("iframe");
                
                function jsIframeSetAttribute(attrName, attrValue) {
                    console.log("wrapped Iframe setAttribute " + attrName);
                    var attrConverted = JSJS.identifyConvertValue(jsObjs.cx, attrValue);
                    switch (attrName) {
                        case "allowTransparency":
                        case "frameBorder":
                        case "scrolling":
                        case "tabIndex":
                        case "name":
                            console.log("setting iframe " + attrName + "=" + attrConverted);
                            wrappedElem.setAttribute(attrName, attrConverted);
                            return null;
                    }
                    throw "Not Allowed";
                }
                var wrappedIframeSetAttribute = JSJS.wrapFunction({
                    func: jsIframeSetAttribute,
                    args: [JSJS.Types.charPtr, JSJS.Types.dynamicPtr],
                    returns: null});
                var ptrIframeSetAttribute = JSJS.NewFunction(jsObjs.cx, wrappedIframeSetAttribute, 2, "setAttribute");
                
                function jsIframeGetAttribute(attrName) {
                    console.log("wrapped Iframe getAttribute " + attrName);
                    switch (attrName) {
                        case "style":
                            return {'type': JSJS.Types.charPtr, 'val': wrappedElem.style};
                            break;
                    }
                    throw "Not Implemented";
                }
                var wrappedIframeGetAttribute = JSJS.wrapFunction({
                    func: jsIframeGetAttribute,
                    args: [JSJS.Types.charPtr],
                    returns: null});
                var ptrIframeGetAttribute = JSJS.NewFunction(jsObjs.cx, wrappedIframeGetAttribute, 1, "getAttribute");
                
                function jsIframeAddEventListener(type, listener, useCapture) {
                    console.log("wrapped Iframe addEventListener " + type);
                    if (type == "load") {
                        wrappedElem.addEventListener("load", function() {
                            var jsvalout = Module.allocate(2, 'i32');
                            _OBJECT_TO_JSVAL(jsvalout, listener);
                            assert(_JSVAL_IS_OBJECT(jsvalout));
                            console.log("about to call iframe callback");
                            JSJS.CallFunctionValue(jsObjs.cx, jsObjs.glob, jsvalout);
                            console.log("finished calling iframe load");
                        });
                        return undefined;
                    }
                    throw "Not Implemented";
                }
                var wrappedIframeAddEventListener = JSJS.wrapFunction({
                    func: jsIframeAddEventListener,
                    args: [JSJS.Types.charPtr, JSJS.Types.objPtr, JSJS.Types.bool],
                    numRequired: 2,
                    returns: null});
                var ptrIframeAddEventListener = JSJS.NewFunction(jsObjs.cx, wrappedIframeAddEventListener, 1, "addEventListener");
                
                return makeWrappedElement(wrappedElem,
                        function getter(propName) {
                            console.log("iframe getter " + propName);
                            switch (propName) {
                                case "id":
                                    return {'type': JSJS.Types.charPtr, 'val': wrappedElem.id};
                                case "setAttribute":
                                    return {'type': JSJS.Types.funcPtr, 'val': ptrIframeSetAttribute};
                                case "getAttribute":
                                    return {'type': JSJS.Types.funcPtr, 'val': ptrIframeGetAttribute};
                                case "style":
                                    return {'type': JSJS.Types.charPtr, 'val': wrappedElem.style};
                                case "addEventListener":
                                    return {'type': JSJS.Types.funcPtr, 'val': ptrIframeAddEventListener};
                            }
                        },
                        function setter(cx, obj, propName, strict, val, jsval) {
                            console.log("iframe setter " + propName);
                            if (propName == "id") {
                                wrappedElem.id = val;
                            } else if (propName == "src") {
                                var l = document.createElement("a");
                                l.href = val;
                                if (l.hostname == "platform.twitter.com") {
                                    console.log("setting iframe source to " + val);
                                    wrappedElem.src = val;
                                }
                            }
                        },
                        function resolver(propName) {
                            console.log("iframe resolve " + propName);
                            return 1;
                        }
                );
            }
        }
        var wrappedIframeCloneNode = JSJS.wrapFunction({
            func : jsIframeCloneNode,
            args : [ JSJS.Types.bool ],
            returns : JSJS.Types.objPtr
        });
        var ptrIframeClone = JSJS.NewFunction(jsObjs.cx,
                wrappedIframeCloneNode, 1, "cloneNode");

        function jsCreateElement(elemName) {
            console.log("create element " + elemName);
            if (elemName == "a") {
                return JSJS.NewObject(jsObjs.cx, 0, 0, jsDocument);
            } else if (elemName == "iframe") {
                return makeWrappedElement(document.createElement("iframe"),
                        function(propName) {
                            console.log("wrapped iframe getter " + propName);
                            switch (propName) {
                                case "cloneNode":
                                    return {
                                        'type' : JSJS.Types.funcPtr,
                                        'val' : ptrIframeClone
                                    };
                                    break;
                            }
                        });
            }
            return null;
        }
        var wrappedCreateElement = JSJS.wrapFunction({
            func : jsCreateElement,
            args : [ JSJS.Types.charPtr ],
            returns : JSJS.Types.objPtr
        });
        var ptrCreateElement = JSJS.NewFunction(jsObjs.cx,
                wrappedCreateElement, 1, "createElement");

        function jsAddEventListener(eventName, callback, useCapture) {
            console.log("add event listener " + eventName);
        }
        var wrappedAddEventListener = JSJS.wrapFunction({
            func : jsAddEventListener,
            args : [ JSJS.Types.charPtr, JSJS.Types.funcPtr ],
            numRequired : 2,
            returns : null
        });
        var ptrAddEventListener = JSJS.NewFunction(jsObjs.cx,
                wrappedAddEventListener, 1, "createElement");

        function jsQuerySelectorAll(selectors) {
            console.log("querySelectorAll " + selectors);
            switch (selectors) {
                case "a.twitter-share-button":
                    return [];
                default:
                    return [];
            }
            throw "Not implemented";
        }
        var wrappedQuerySelectorAll = JSJS.wrapFunction({
            func : jsQuerySelectorAll,
            args : [ JSJS.Types.charPtr ],
            returns : JSJS.Types.arrayPtr
        });
        var ptrQuerySelectorAll = JSJS.NewFunction(jsObjs.cx,
                wrappedQuerySelectorAll, 1, "querySelectorAll");

        function jsQuerySelector(selectors) {
            console.log("querySelector " + selectors);
            throw "Not implemented"
        }
        var wrappedQuerySelector = JSJS.wrapFunction({
            func : jsQuerySelector,
            args : [ JSJS.Types.charPtr ],
            returns : null
        });
        var ptrQuerySelector = JSJS.NewFunction(jsObjs.cx,
                wrappedQuerySelector, 1, "querySelector");

        function documentResolveProperty(propName) {
            console.log("document resolve " + propName);
            return 1;
        }

        function documentGetProperty(propName) {
            console.log('getting document property ' + propName);
            switch (propName) {
                case "getElementsByTagName":
                    return {'type' : JSJS.Types.funcPtr, 'val' : ptrGetElementsByTagName};
                    break;
                case "getElementById":
                    return {'type' : JSJS.Types.funcPtr, 'val' : ptrGetElementById};
                    break;
                case "createElement":
                    return {'type' : JSJS.Types.funcPtr, 'val' : ptrCreateElement};
                    break;
                case "readyState":
                    return {'type' : JSJS.Types.charPtr, 'val' : "complete"};
                    break;
                case "addEventListener":
                    return {'type' : JSJS.Types.funcPtr, 'val' : ptrAddEventListener};
                    break;
                case "title":
                    return {'type' : JSJS.Types.charPtr, 'val' : document.title};
                    break;
                case "documentElement":
                    return {'type' : JSJS.Types.objPtr, 'val' : makeWrappedElement(document.documentElement)};
                    break;
                case "querySelectorAll":
                    return {'type' : JSJS.Types.funcPtr, 'val' : ptrQuerySelectorAll};
                    break;
                case "querySelector":
                    return {'type' : JSJS.Types.funcPtr, 'val' : ptrQuerySelector};
                    break;
                case "location":
                    return {'type' : JSJS.Types.objPtr, 'val' : jsLocation};
                    break;
                case "body":
                    {
                    
                    function jsBodyInsertBefore(newElement, referenceElement) {
                        console.log("body insertBefore");
                        if (newElement in wrappedMap && wrappedMap[newElement].tagName == "IFRAME") {
                            document.body.insertBefore(wrappedMap[newElement], document.body.firstChild);
                            return null;
                        }
                        throw "Not Implemented";
                    }
                    var wrappedBodyInsertBefore = JSJS.wrapFunction({
                        func: jsBodyInsertBefore,
                        args: [JSJS.Types.objPtr, JSJS.Types.objPtr],
                        returns: null});
                    var ptrBodyInsertBefore = JSJS.NewFunction(jsObjs.cx, wrappedBodyInsertBefore, 2, "insertBefore");
                    
                    return {'type': JSJS.Types.objPtr, 'val': makeWrappedElement(document.body,
                            function getter(propName) {
                                console.log("document.body getter " + propName);
                                switch (propName) {
                                    case "insertBefore":
                                        return {'type': JSJS.Types.funcPtr, 'val': ptrBodyInsertBefore};
                                }
                            }, function setter(cx, obj, propName, strict, val, jsval) {
                                console.log("document.body setter " + propName);
                            })}
                    }
            }
            console.log("returning nothing for document." + propName);
            return true;
        }

        var jsDocumentClass = JSJS.CreateClass(JSJS['JSCLASS_GLOBAL_FLAGS'],
                JSJS['PropertyStub'], JSJS['PropertyStub'], JSJS.wrapGetter(
                        documentGetProperty, JSJS.Types.bool),
                JSJS['StrictPropertyStub'], JSJS['EnumerateStub'], JSJS
                        .wrapResolver(documentResolveProperty),
                JSJS['ConvertStub'], JSJS['FinalizeStub']);
        var jsDocument = JSJS.DefineObject(jsObjs.cx, jsObjs.glob, "document",
                jsDocumentClass, 0, 0);
        JSJS.SetProperty(jsObjs.cx, jsDocument, "querySelectorAll",
                ptrQuerySelectorAll);
        JSJS.SetProperty(jsObjs.cx, jsDocument, "querySelector",
                ptrQuerySelector);

        function jsPostMessage(message, origin) {
            console.log("postMessage " + origin);
            throw "Not implemented";
        }
        var wrappedPostMessage = JSJS.wrapFunction({
            func : jsPostMessage,
            args : [ JSJS.Types.objPtr, JSJS.Types.charPtr ],
            returns : null
        });
        var ptrPostMessage = JSJS.NewFunction(jsObjs.cx, wrappedPostMessage, 2,
                "postMessage");

        function windowGetProperty(propName) {
            console.log('getting window property ' + propName);
            switch (propName) {
                case "postMessage":
                    return {
                        'type' : JSJS.Types.funcPtr,
                        'val' : ptrPostMessage
                    };
                    break;
                default:
                    console.log("returning global value for prop " + propName);
                    return {
                        'type' : null,
                        'val' : JSJS.GetProperty(jsObjs.cx, jsObjs.glob,
                                propName)
                    };
                    break;
            }
            return true;
        }
        function windowSetProperty(cx, obj, idStrReal, strict, val, jsval) {
            console.log('setting window property ' + idStrReal + " = " + val
                    + " / " + jsval);
            // Copy window property sets to the global object
            JSJS.SetProperty(jsObjs.cx, jsObjs.glob, idStrReal, jsval);
            return true;
        }
        function windowResolveProperty(propName) {
            console.log("window resolve prop " + propName);
            return 1;
        }
        var jsWindowClass = JSJS.CreateClass(JSJS['JSCLASS_GLOBAL_FLAGS'],
                JSJS['PropertyStub'], JSJS['PropertyStub'], JSJS.wrapGetter(
                        windowGetProperty, JSJS.Types.bool), JSJS
                        .wrapSetter(windowSetProperty), JSJS['EnumerateStub'],
                JSJS.wrapResolver(windowResolveProperty), JSJS['ConvertStub'],
                JSJS['FinalizeStub']);
        var jsWindow = JSJS.DefineObject(jsObjs.cx, jsObjs.glob, "window",
                jsWindowClass, 0, 0);

        console.log("starting exec");
        var rval = JSJS.EvaluateScript(jsObjs.cx, jsObjs.glob, srcContents);
    }

    window.onload = init;
</script>
</head>
<body>
<h1>Hello</h1>
<a href="https://twitter.com/share" class="twitter-share-button" data-via="jterrace" data-size="large">Tweet</a>
<h2>Hi</h2>
</body>
</html>